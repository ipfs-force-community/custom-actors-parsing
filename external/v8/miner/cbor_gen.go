// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package miner

import (
	"fmt"
	"io"
	"math"
	"sort"

	address "github.com/filecoin-project/go-address"
	abi "github.com/filecoin-project/go-state-types/abi"
	miner "github.com/filecoin-project/go-state-types/builtin/v8/miner"
	proof "github.com/filecoin-project/go-state-types/proof"
	cid "github.com/ipfs/go-cid"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf
var _ = cid.Undef
var _ = math.E
var _ = sort.Sort

var lengthBufState = []byte{143}

func (t *State) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufState); err != nil {
		return err
	}

	// t.Info (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Info); err != nil {
		return xerrors.Errorf("failed to write cid field t.Info: %w", err)
	}

	// t.PreCommitDeposits (big.Int) (struct)
	if err := t.PreCommitDeposits.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.LockedFunds (big.Int) (struct)
	if err := t.LockedFunds.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.VestingFunds (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.VestingFunds); err != nil {
		return xerrors.Errorf("failed to write cid field t.VestingFunds: %w", err)
	}

	// t.FeeDebt (big.Int) (struct)
	if err := t.FeeDebt.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.InitialPledge (big.Int) (struct)
	if err := t.InitialPledge.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.PreCommittedSectors (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.PreCommittedSectors); err != nil {
		return xerrors.Errorf("failed to write cid field t.PreCommittedSectors: %w", err)
	}

	// t.PreCommittedSectorsCleanUp (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.PreCommittedSectorsCleanUp); err != nil {
		return xerrors.Errorf("failed to write cid field t.PreCommittedSectorsCleanUp: %w", err)
	}

	// t.AllocatedSectors (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.AllocatedSectors); err != nil {
		return xerrors.Errorf("failed to write cid field t.AllocatedSectors: %w", err)
	}

	// t.Sectors (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Sectors); err != nil {
		return xerrors.Errorf("failed to write cid field t.Sectors: %w", err)
	}

	// t.ProvingPeriodStart (abi.ChainEpoch) (int64)
	if t.ProvingPeriodStart >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.ProvingPeriodStart)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.ProvingPeriodStart-1)); err != nil {
			return err
		}
	}

	// t.CurrentDeadline (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.CurrentDeadline)); err != nil {
		return err
	}

	// t.Deadlines (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.Deadlines); err != nil {
		return xerrors.Errorf("failed to write cid field t.Deadlines: %w", err)
	}

	// t.EarlyTerminations (bitfield.BitField) (struct)
	if err := t.EarlyTerminations.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.DeadlineCronActive (bool) (bool)
	if err := cbg.WriteBool(w, t.DeadlineCronActive); err != nil {
		return err
	}
	return nil
}

func (t *State) UnmarshalCBOR(r io.Reader) (err error) {
	*t = State{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 15 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Info (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Info: %w", err)
		}

		t.Info = c

	}
	// t.PreCommitDeposits (big.Int) (struct)

	{

		if err := t.PreCommitDeposits.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.PreCommitDeposits: %w", err)
		}

	}
	// t.LockedFunds (big.Int) (struct)

	{

		if err := t.LockedFunds.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.LockedFunds: %w", err)
		}

	}
	// t.VestingFunds (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.VestingFunds: %w", err)
		}

		t.VestingFunds = c

	}
	// t.FeeDebt (big.Int) (struct)

	{

		if err := t.FeeDebt.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.FeeDebt: %w", err)
		}

	}
	// t.InitialPledge (big.Int) (struct)

	{

		if err := t.InitialPledge.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.InitialPledge: %w", err)
		}

	}
	// t.PreCommittedSectors (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.PreCommittedSectors: %w", err)
		}

		t.PreCommittedSectors = c

	}
	// t.PreCommittedSectorsCleanUp (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.PreCommittedSectorsCleanUp: %w", err)
		}

		t.PreCommittedSectorsCleanUp = c

	}
	// t.AllocatedSectors (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.AllocatedSectors: %w", err)
		}

		t.AllocatedSectors = c

	}
	// t.Sectors (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Sectors: %w", err)
		}

		t.Sectors = c

	}
	// t.ProvingPeriodStart (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.ProvingPeriodStart = abi.ChainEpoch(extraI)
	}
	// t.CurrentDeadline (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.CurrentDeadline = uint64(extra)

	}
	// t.Deadlines (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Deadlines: %w", err)
		}

		t.Deadlines = c

	}
	// t.EarlyTerminations (bitfield.BitField) (struct)

	{

		if err := t.EarlyTerminations.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.EarlyTerminations: %w", err)
		}

	}
	// t.DeadlineCronActive (bool) (bool)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}
	if maj != cbg.MajOther {
		return fmt.Errorf("booleans must be major type 7")
	}
	switch extra {
	case 20:
		t.DeadlineCronActive = false
	case 21:
		t.DeadlineCronActive = true
	default:
		return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
	}
	return nil
}

var lengthBufGetControlAddressesReturn = []byte{131}

func (t *GetControlAddressesReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufGetControlAddressesReturn); err != nil {
		return err
	}

	// t.Owner (address.Address) (struct)
	if err := t.Owner.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Worker (address.Address) (struct)
	if err := t.Worker.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.ControlAddrs ([]address.Address) (slice)
	if len(t.ControlAddrs) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.ControlAddrs was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.ControlAddrs))); err != nil {
		return err
	}
	for _, v := range t.ControlAddrs {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *GetControlAddressesReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = GetControlAddressesReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Owner (address.Address) (struct)

	{

		if err := t.Owner.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Owner: %w", err)
		}

	}
	// t.Worker (address.Address) (struct)

	{

		if err := t.Worker.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Worker: %w", err)
		}

	}
	// t.ControlAddrs ([]address.Address) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.ControlAddrs: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.ControlAddrs = make([]address.Address, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v address.Address
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.ControlAddrs[i] = v
	}

	return nil
}

var lengthBufChangeWorkerAddressParams = []byte{130}

func (t *ChangeWorkerAddressParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufChangeWorkerAddressParams); err != nil {
		return err
	}

	// t.NewWorker (address.Address) (struct)
	if err := t.NewWorker.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.NewControlAddrs ([]address.Address) (slice)
	if len(t.NewControlAddrs) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.NewControlAddrs was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.NewControlAddrs))); err != nil {
		return err
	}
	for _, v := range t.NewControlAddrs {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *ChangeWorkerAddressParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ChangeWorkerAddressParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.NewWorker (address.Address) (struct)

	{

		if err := t.NewWorker.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.NewWorker: %w", err)
		}

	}
	// t.NewControlAddrs ([]address.Address) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.NewControlAddrs: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.NewControlAddrs = make([]address.Address, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v address.Address
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.NewControlAddrs[i] = v
	}

	return nil
}

var lengthBufChangePeerIDParams = []byte{129}

func (t *ChangePeerIDParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufChangePeerIDParams); err != nil {
		return err
	}

	// t.NewID ([]uint8) (slice)
	if len(t.NewID) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.NewID was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.NewID))); err != nil {
		return err
	}

	if _, err := cw.Write(t.NewID[:]); err != nil {
		return err
	}
	return nil
}

func (t *ChangePeerIDParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ChangePeerIDParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.NewID ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.NewID: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.NewID = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.NewID[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufSubmitWindowedPoStParams = []byte{133}

func (t *SubmitWindowedPoStParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufSubmitWindowedPoStParams); err != nil {
		return err
	}

	// t.Deadline (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Deadline)); err != nil {
		return err
	}

	// t.Partitions ([]miner.PoStPartition) (slice)
	if len(t.Partitions) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Partitions was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Partitions))); err != nil {
		return err
	}
	for _, v := range t.Partitions {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}

	// t.Proofs ([]proof.PoStProof) (slice)
	if len(t.Proofs) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Proofs was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Proofs))); err != nil {
		return err
	}
	for _, v := range t.Proofs {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}

	// t.ChainCommitEpoch (abi.ChainEpoch) (int64)
	if t.ChainCommitEpoch >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.ChainCommitEpoch)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.ChainCommitEpoch-1)); err != nil {
			return err
		}
	}

	// t.ChainCommitRand (abi.Randomness) (slice)
	if len(t.ChainCommitRand) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.ChainCommitRand was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.ChainCommitRand))); err != nil {
		return err
	}

	if _, err := cw.Write(t.ChainCommitRand[:]); err != nil {
		return err
	}
	return nil
}

func (t *SubmitWindowedPoStParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = SubmitWindowedPoStParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 5 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Deadline (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Deadline = uint64(extra)

	}
	// t.Partitions ([]miner.PoStPartition) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Partitions: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Partitions = make([]miner.PoStPartition, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v miner.PoStPartition
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Partitions[i] = v
	}

	// t.Proofs ([]proof.PoStProof) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Proofs: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Proofs = make([]proof.PoStProof, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v proof.PoStProof
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Proofs[i] = v
	}

	// t.ChainCommitEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.ChainCommitEpoch = abi.ChainEpoch(extraI)
	}
	// t.ChainCommitRand (abi.Randomness) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.ChainCommitRand: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.ChainCommitRand = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.ChainCommitRand[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufPreCommitSectorParams = []byte{138}

func (t *PreCommitSectorParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufPreCommitSectorParams); err != nil {
		return err
	}

	// t.SealProof (abi.RegisteredSealProof) (int64)
	if t.SealProof >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.SealProof)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.SealProof-1)); err != nil {
			return err
		}
	}

	// t.SectorNumber (abi.SectorNumber) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.SectorNumber)); err != nil {
		return err
	}

	// t.SealedCID (cid.Cid) (struct)

	if err := cbg.WriteCid(cw, t.SealedCID); err != nil {
		return xerrors.Errorf("failed to write cid field t.SealedCID: %w", err)
	}

	// t.SealRandEpoch (abi.ChainEpoch) (int64)
	if t.SealRandEpoch >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.SealRandEpoch)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.SealRandEpoch-1)); err != nil {
			return err
		}
	}

	// t.DealIDs ([]abi.DealID) (slice)
	if len(t.DealIDs) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.DealIDs was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.DealIDs))); err != nil {
		return err
	}
	for _, v := range t.DealIDs {
		if err := cw.CborWriteHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
			return err
		}
	}

	// t.Expiration (abi.ChainEpoch) (int64)
	if t.Expiration >= 0 {
		if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Expiration)); err != nil {
			return err
		}
	} else {
		if err := cw.WriteMajorTypeHeader(cbg.MajNegativeInt, uint64(-t.Expiration-1)); err != nil {
			return err
		}
	}

	// t.ReplaceCapacity (bool) (bool)
	if err := cbg.WriteBool(w, t.ReplaceCapacity); err != nil {
		return err
	}

	// t.ReplaceSectorDeadline (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.ReplaceSectorDeadline)); err != nil {
		return err
	}

	// t.ReplaceSectorPartition (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.ReplaceSectorPartition)); err != nil {
		return err
	}

	// t.ReplaceSectorNumber (abi.SectorNumber) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.ReplaceSectorNumber)); err != nil {
		return err
	}

	return nil
}

func (t *PreCommitSectorParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = PreCommitSectorParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 10 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.SealProof (abi.RegisteredSealProof) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.SealProof = abi.RegisteredSealProof(extraI)
	}
	// t.SectorNumber (abi.SectorNumber) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.SectorNumber = abi.SectorNumber(extra)

	}
	// t.SealedCID (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(cr)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.SealedCID: %w", err)
		}

		t.SealedCID = c

	}
	// t.SealRandEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.SealRandEpoch = abi.ChainEpoch(extraI)
	}
	// t.DealIDs ([]abi.DealID) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.DealIDs: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.DealIDs = make([]abi.DealID, extra)
	}

	for i := 0; i < int(extra); i++ {

		maj, val, err := cr.ReadHeader()
		if err != nil {
			return xerrors.Errorf("failed to read uint64 for t.DealIDs slice: %w", err)
		}

		if maj != cbg.MajUnsignedInt {
			return xerrors.Errorf("value read for array t.DealIDs was not a uint, instead got %d", maj)
		}

		t.DealIDs[i] = abi.DealID(val)
	}

	// t.Expiration (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cr.ReadHeader()
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.Expiration = abi.ChainEpoch(extraI)
	}
	// t.ReplaceCapacity (bool) (bool)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}
	if maj != cbg.MajOther {
		return fmt.Errorf("booleans must be major type 7")
	}
	switch extra {
	case 20:
		t.ReplaceCapacity = false
	case 21:
		t.ReplaceCapacity = true
	default:
		return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
	}
	// t.ReplaceSectorDeadline (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.ReplaceSectorDeadline = uint64(extra)

	}
	// t.ReplaceSectorPartition (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.ReplaceSectorPartition = uint64(extra)

	}
	// t.ReplaceSectorNumber (abi.SectorNumber) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.ReplaceSectorNumber = abi.SectorNumber(extra)

	}
	return nil
}

var lengthBufProveCommitSectorParams = []byte{130}

func (t *ProveCommitSectorParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufProveCommitSectorParams); err != nil {
		return err
	}

	// t.SectorNumber (abi.SectorNumber) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.SectorNumber)); err != nil {
		return err
	}

	// t.Proof ([]uint8) (slice)
	if len(t.Proof) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.Proof was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.Proof))); err != nil {
		return err
	}

	if _, err := cw.Write(t.Proof[:]); err != nil {
		return err
	}
	return nil
}

func (t *ProveCommitSectorParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ProveCommitSectorParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.SectorNumber (abi.SectorNumber) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.SectorNumber = abi.SectorNumber(extra)

	}
	// t.Proof ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.Proof: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.Proof = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.Proof[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufExtendSectorExpirationParams = []byte{129}

func (t *ExtendSectorExpirationParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufExtendSectorExpirationParams); err != nil {
		return err
	}

	// t.Extensions ([]miner.ExpirationExtension) (slice)
	if len(t.Extensions) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Extensions was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Extensions))); err != nil {
		return err
	}
	for _, v := range t.Extensions {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *ExtendSectorExpirationParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ExtendSectorExpirationParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Extensions ([]miner.ExpirationExtension) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Extensions: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Extensions = make([]miner.ExpirationExtension, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v miner.ExpirationExtension
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Extensions[i] = v
	}

	return nil
}

var lengthBufTerminateSectorsParams = []byte{129}

func (t *TerminateSectorsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTerminateSectorsParams); err != nil {
		return err
	}

	// t.Terminations ([]miner.TerminationDeclaration) (slice)
	if len(t.Terminations) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Terminations was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Terminations))); err != nil {
		return err
	}
	for _, v := range t.Terminations {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *TerminateSectorsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TerminateSectorsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Terminations ([]miner.TerminationDeclaration) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Terminations: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Terminations = make([]miner.TerminationDeclaration, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v miner.TerminationDeclaration
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Terminations[i] = v
	}

	return nil
}

var lengthBufTerminateSectorsReturn = []byte{129}

func (t *TerminateSectorsReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufTerminateSectorsReturn); err != nil {
		return err
	}

	// t.Done (bool) (bool)
	if err := cbg.WriteBool(w, t.Done); err != nil {
		return err
	}
	return nil
}

func (t *TerminateSectorsReturn) UnmarshalCBOR(r io.Reader) (err error) {
	*t = TerminateSectorsReturn{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Done (bool) (bool)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}
	if maj != cbg.MajOther {
		return fmt.Errorf("booleans must be major type 7")
	}
	switch extra {
	case 20:
		t.Done = false
	case 21:
		t.Done = true
	default:
		return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
	}
	return nil
}

var lengthBufDeclareFaultsParams = []byte{129}

func (t *DeclareFaultsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufDeclareFaultsParams); err != nil {
		return err
	}

	// t.Faults ([]miner.FaultDeclaration) (slice)
	if len(t.Faults) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Faults was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Faults))); err != nil {
		return err
	}
	for _, v := range t.Faults {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *DeclareFaultsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = DeclareFaultsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Faults ([]miner.FaultDeclaration) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Faults: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Faults = make([]miner.FaultDeclaration, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v miner.FaultDeclaration
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Faults[i] = v
	}

	return nil
}

var lengthBufDeclareFaultsRecoveredParams = []byte{129}

func (t *DeclareFaultsRecoveredParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufDeclareFaultsRecoveredParams); err != nil {
		return err
	}

	// t.Recoveries ([]miner.RecoveryDeclaration) (slice)
	if len(t.Recoveries) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Recoveries was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Recoveries))); err != nil {
		return err
	}
	for _, v := range t.Recoveries {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *DeclareFaultsRecoveredParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = DeclareFaultsRecoveredParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Recoveries ([]miner.RecoveryDeclaration) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Recoveries: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Recoveries = make([]miner.RecoveryDeclaration, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v miner.RecoveryDeclaration
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Recoveries[i] = v
	}

	return nil
}

var lengthBufDeferredCronEventParams = []byte{131}

func (t *DeferredCronEventParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufDeferredCronEventParams); err != nil {
		return err
	}

	// t.EventPayload ([]uint8) (slice)
	if len(t.EventPayload) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.EventPayload was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.EventPayload))); err != nil {
		return err
	}

	if _, err := cw.Write(t.EventPayload[:]); err != nil {
		return err
	}

	// t.RewardSmoothed (smoothing.FilterEstimate) (struct)
	if err := t.RewardSmoothed.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.QualityAdjPowerSmoothed (smoothing.FilterEstimate) (struct)
	if err := t.QualityAdjPowerSmoothed.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *DeferredCronEventParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = DeferredCronEventParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.EventPayload ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.EventPayload: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.EventPayload = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.EventPayload[:]); err != nil {
		return err
	}
	// t.RewardSmoothed (smoothing.FilterEstimate) (struct)

	{

		if err := t.RewardSmoothed.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.RewardSmoothed: %w", err)
		}

	}
	// t.QualityAdjPowerSmoothed (smoothing.FilterEstimate) (struct)

	{

		if err := t.QualityAdjPowerSmoothed.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.QualityAdjPowerSmoothed: %w", err)
		}

	}
	return nil
}

var lengthBufCheckSectorProvenParams = []byte{129}

func (t *CheckSectorProvenParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufCheckSectorProvenParams); err != nil {
		return err
	}

	// t.SectorNumber (abi.SectorNumber) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.SectorNumber)); err != nil {
		return err
	}

	return nil
}

func (t *CheckSectorProvenParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = CheckSectorProvenParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.SectorNumber (abi.SectorNumber) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.SectorNumber = abi.SectorNumber(extra)

	}
	return nil
}

var lengthBufApplyRewardParams = []byte{130}

func (t *ApplyRewardParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufApplyRewardParams); err != nil {
		return err
	}

	// t.Reward (big.Int) (struct)
	if err := t.Reward.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.Penalty (big.Int) (struct)
	if err := t.Penalty.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *ApplyRewardParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ApplyRewardParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Reward (big.Int) (struct)

	{

		if err := t.Reward.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Reward: %w", err)
		}

	}
	// t.Penalty (big.Int) (struct)

	{

		if err := t.Penalty.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Penalty: %w", err)
		}

	}
	return nil
}

var lengthBufReportConsensusFaultParams = []byte{131}

func (t *ReportConsensusFaultParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufReportConsensusFaultParams); err != nil {
		return err
	}

	// t.BlockHeader1 ([]uint8) (slice)
	if len(t.BlockHeader1) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.BlockHeader1 was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.BlockHeader1))); err != nil {
		return err
	}

	if _, err := cw.Write(t.BlockHeader1[:]); err != nil {
		return err
	}

	// t.BlockHeader2 ([]uint8) (slice)
	if len(t.BlockHeader2) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.BlockHeader2 was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.BlockHeader2))); err != nil {
		return err
	}

	if _, err := cw.Write(t.BlockHeader2[:]); err != nil {
		return err
	}

	// t.BlockHeaderExtra ([]uint8) (slice)
	if len(t.BlockHeaderExtra) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.BlockHeaderExtra was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.BlockHeaderExtra))); err != nil {
		return err
	}

	if _, err := cw.Write(t.BlockHeaderExtra[:]); err != nil {
		return err
	}
	return nil
}

func (t *ReportConsensusFaultParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ReportConsensusFaultParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.BlockHeader1 ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.BlockHeader1: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.BlockHeader1 = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.BlockHeader1[:]); err != nil {
		return err
	}
	// t.BlockHeader2 ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.BlockHeader2: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.BlockHeader2 = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.BlockHeader2[:]); err != nil {
		return err
	}
	// t.BlockHeaderExtra ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.BlockHeaderExtra: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.BlockHeaderExtra = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.BlockHeaderExtra[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufWithdrawBalanceParams = []byte{129}

func (t *WithdrawBalanceParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufWithdrawBalanceParams); err != nil {
		return err
	}

	// t.AmountRequested (big.Int) (struct)
	if err := t.AmountRequested.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *WithdrawBalanceParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = WithdrawBalanceParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.AmountRequested (big.Int) (struct)

	{

		if err := t.AmountRequested.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.AmountRequested: %w", err)
		}

	}
	return nil
}

var lengthBufConfirmSectorProofsParams = []byte{132}

func (t *ConfirmSectorProofsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufConfirmSectorProofsParams); err != nil {
		return err
	}

	// t.Sectors ([]abi.SectorNumber) (slice)
	if len(t.Sectors) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Sectors was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Sectors))); err != nil {
		return err
	}
	for _, v := range t.Sectors {
		if err := cw.CborWriteHeader(cbg.MajUnsignedInt, uint64(v)); err != nil {
			return err
		}
	}

	// t.RewardSmoothed (smoothing.FilterEstimate) (struct)
	if err := t.RewardSmoothed.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.RewardBaselinePower (big.Int) (struct)
	if err := t.RewardBaselinePower.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.QualityAdjPowerSmoothed (smoothing.FilterEstimate) (struct)
	if err := t.QualityAdjPowerSmoothed.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *ConfirmSectorProofsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ConfirmSectorProofsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 4 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Sectors ([]abi.SectorNumber) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Sectors: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Sectors = make([]abi.SectorNumber, extra)
	}

	for i := 0; i < int(extra); i++ {

		maj, val, err := cr.ReadHeader()
		if err != nil {
			return xerrors.Errorf("failed to read uint64 for t.Sectors slice: %w", err)
		}

		if maj != cbg.MajUnsignedInt {
			return xerrors.Errorf("value read for array t.Sectors was not a uint, instead got %d", maj)
		}

		t.Sectors[i] = abi.SectorNumber(val)
	}

	// t.RewardSmoothed (smoothing.FilterEstimate) (struct)

	{

		if err := t.RewardSmoothed.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.RewardSmoothed: %w", err)
		}

	}
	// t.RewardBaselinePower (big.Int) (struct)

	{

		if err := t.RewardBaselinePower.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.RewardBaselinePower: %w", err)
		}

	}
	// t.QualityAdjPowerSmoothed (smoothing.FilterEstimate) (struct)

	{

		if err := t.QualityAdjPowerSmoothed.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.QualityAdjPowerSmoothed: %w", err)
		}

	}
	return nil
}

var lengthBufChangeMultiaddrsParams = []byte{129}

func (t *ChangeMultiaddrsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufChangeMultiaddrsParams); err != nil {
		return err
	}

	// t.NewMultiaddrs ([][]uint8) (slice)
	if len(t.NewMultiaddrs) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.NewMultiaddrs was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.NewMultiaddrs))); err != nil {
		return err
	}
	for _, v := range t.NewMultiaddrs {
		if len(v) > cbg.ByteArrayMaxLen {
			return xerrors.Errorf("Byte array in field v was too long")
		}

		if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(v))); err != nil {
			return err
		}

		if _, err := cw.Write(v[:]); err != nil {
			return err
		}
	}
	return nil
}

func (t *ChangeMultiaddrsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ChangeMultiaddrsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.NewMultiaddrs ([][]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.NewMultiaddrs: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.NewMultiaddrs = make([][]uint8, extra)
	}

	for i := 0; i < int(extra); i++ {
		{
			var maj byte
			var extra uint64
			var err error

			maj, extra, err = cr.ReadHeader()
			if err != nil {
				return err
			}

			if extra > cbg.ByteArrayMaxLen {
				return fmt.Errorf("t.NewMultiaddrs[i]: byte array too large (%d)", extra)
			}
			if maj != cbg.MajByteString {
				return fmt.Errorf("expected byte array")
			}

			if extra > 0 {
				t.NewMultiaddrs[i] = make([]uint8, extra)
			}

			if _, err := io.ReadFull(cr, t.NewMultiaddrs[i][:]); err != nil {
				return err
			}
		}
	}

	return nil
}

var lengthBufCompactPartitionsParams = []byte{130}

func (t *CompactPartitionsParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufCompactPartitionsParams); err != nil {
		return err
	}

	// t.Deadline (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Deadline)); err != nil {
		return err
	}

	// t.Partitions (bitfield.BitField) (struct)
	if err := t.Partitions.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *CompactPartitionsParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = CompactPartitionsParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Deadline (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Deadline = uint64(extra)

	}
	// t.Partitions (bitfield.BitField) (struct)

	{

		if err := t.Partitions.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.Partitions: %w", err)
		}

	}
	return nil
}

var lengthBufCompactSectorNumbersParams = []byte{129}

func (t *CompactSectorNumbersParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufCompactSectorNumbersParams); err != nil {
		return err
	}

	// t.MaskSectorNumbers (bitfield.BitField) (struct)
	if err := t.MaskSectorNumbers.MarshalCBOR(cw); err != nil {
		return err
	}
	return nil
}

func (t *CompactSectorNumbersParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = CompactSectorNumbersParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.MaskSectorNumbers (bitfield.BitField) (struct)

	{

		if err := t.MaskSectorNumbers.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.MaskSectorNumbers: %w", err)
		}

	}
	return nil
}

var lengthBufDisputeWindowedPoStParams = []byte{130}

func (t *DisputeWindowedPoStParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufDisputeWindowedPoStParams); err != nil {
		return err
	}

	// t.Deadline (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.Deadline)); err != nil {
		return err
	}

	// t.PoStIndex (uint64) (uint64)

	if err := cw.WriteMajorTypeHeader(cbg.MajUnsignedInt, uint64(t.PoStIndex)); err != nil {
		return err
	}

	return nil
}

func (t *DisputeWindowedPoStParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = DisputeWindowedPoStParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Deadline (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.Deadline = uint64(extra)

	}
	// t.PoStIndex (uint64) (uint64)

	{

		maj, extra, err = cr.ReadHeader()
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.PoStIndex = uint64(extra)

	}
	return nil
}

var lengthBufPreCommitSectorBatchParams = []byte{129}

func (t *PreCommitSectorBatchParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufPreCommitSectorBatchParams); err != nil {
		return err
	}

	// t.Sectors ([]miner.SectorPreCommitInfo) (slice)
	if len(t.Sectors) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Sectors was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Sectors))); err != nil {
		return err
	}
	for _, v := range t.Sectors {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *PreCommitSectorBatchParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = PreCommitSectorBatchParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Sectors ([]miner.SectorPreCommitInfo) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Sectors: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Sectors = make([]miner.SectorPreCommitInfo, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v miner.SectorPreCommitInfo
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Sectors[i] = v
	}

	return nil
}

var lengthBufProveCommitAggregateParams = []byte{130}

func (t *ProveCommitAggregateParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufProveCommitAggregateParams); err != nil {
		return err
	}

	// t.SectorNumbers (bitfield.BitField) (struct)
	if err := t.SectorNumbers.MarshalCBOR(cw); err != nil {
		return err
	}

	// t.AggregateProof ([]uint8) (slice)
	if len(t.AggregateProof) > cbg.ByteArrayMaxLen {
		return xerrors.Errorf("Byte array in field t.AggregateProof was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajByteString, uint64(len(t.AggregateProof))); err != nil {
		return err
	}

	if _, err := cw.Write(t.AggregateProof[:]); err != nil {
		return err
	}
	return nil
}

func (t *ProveCommitAggregateParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ProveCommitAggregateParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.SectorNumbers (bitfield.BitField) (struct)

	{

		if err := t.SectorNumbers.UnmarshalCBOR(cr); err != nil {
			return xerrors.Errorf("unmarshaling t.SectorNumbers: %w", err)
		}

	}
	// t.AggregateProof ([]uint8) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.ByteArrayMaxLen {
		return fmt.Errorf("t.AggregateProof: byte array too large (%d)", extra)
	}
	if maj != cbg.MajByteString {
		return fmt.Errorf("expected byte array")
	}

	if extra > 0 {
		t.AggregateProof = make([]uint8, extra)
	}

	if _, err := io.ReadFull(cr, t.AggregateProof[:]); err != nil {
		return err
	}
	return nil
}

var lengthBufProveReplicaUpdatesParams = []byte{129}

func (t *ProveReplicaUpdatesParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}

	cw := cbg.NewCborWriter(w)

	if _, err := cw.Write(lengthBufProveReplicaUpdatesParams); err != nil {
		return err
	}

	// t.Updates ([]miner.ReplicaUpdate) (slice)
	if len(t.Updates) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Updates was too long")
	}

	if err := cw.WriteMajorTypeHeader(cbg.MajArray, uint64(len(t.Updates))); err != nil {
		return err
	}
	for _, v := range t.Updates {
		if err := v.MarshalCBOR(cw); err != nil {
			return err
		}
	}
	return nil
}

func (t *ProveReplicaUpdatesParams) UnmarshalCBOR(r io.Reader) (err error) {
	*t = ProveReplicaUpdatesParams{}

	cr := cbg.NewCborReader(r)

	maj, extra, err := cr.ReadHeader()
	if err != nil {
		return err
	}
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()

	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Updates ([]miner.ReplicaUpdate) (slice)

	maj, extra, err = cr.ReadHeader()
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Updates: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Updates = make([]miner.ReplicaUpdate, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v miner.ReplicaUpdate
		if err := v.UnmarshalCBOR(cr); err != nil {
			return err
		}

		t.Updates[i] = v
	}

	return nil
}
